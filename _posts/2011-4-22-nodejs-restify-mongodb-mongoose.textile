---
layout: post
title: Simple example - Node.js, Restify, MongoDb and Mongoose 
type: intermediate
posturl: http://backbonetutorials.com/nodejs-restify-mongodb-mongoose
---

h2. Simple example - Node.js, Restify, MongoDb and Mongoose 

p. Before I start, the Backbone.js parts of this tutorial will be using techniques described in "Organizing your application using Modules":http://backbonetutorials.com/organizing-backbone-using-modules/


h3. The technologies

This stack is great for rapid prototyping and highly intuitive.

h4. Node.js

p. "Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices."


h4. Restify

p. restify is a node.js module built specifically to enable you to build correct REST web services. It borrows heavily from express (intentionally) as that is more or less the de facto API for writing web applications on top of node.js."

h4. MongoDb

p. "MongoDB (from "humongous") is a scalable, high-performance, open source NoSQL database."

h4. Mongoose

p. "Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment."


h3. Getting started

To easily understand this tutorial you should jump straight into the example code base.

h3. "Example Codebase":https://github.com/thomasdavis/backbonetutorials/tree/gh-pages/examples/nodejs-mongodb-mongoose-restify

h3. "Example Demo":http://backbonetutorials.com/examples/nodejs-mongodb-mongoose-restify/

This tutorial will assist you in saving data(Backbone.js Models) to MongoDb and retreiving a list(Backbone.js Collections) of them back.


h3. Building the server

p. In the example repository there is a server.js example which can be executed by running `node server.js`. If you use this example in your own applications make sure to update the Backbone.js "Model":https://github.com/thomasdavis/backbonetutorials/blob/gh-pages/examples/nodejs-mongodb-mongoose-restify/js/models/message.js and "Collection":https://github.com/thomasdavis/backbonetutorials/blob/gh-pages/examples/nodejs-mongodb-mongoose-restify/js/collections/messages.js definitions to match your server address.

h4. Restify configuration
The first thing to do is require the Restify module. Restify will be in control of handling our restFul end points and returning the appropiate JSON.

{% highlight javascript %}
var restify = require('restify');  
var server = restify.createServer();
server.use(restify.bodyParser());
{% endhighlight %}

Note: bodyParser() takes care of turning your request data into a Javascript object on the server automatically.

h4. MongoDb/Mongoose configuration


We simply want to require the MongoDb module and pass it a MongoDb authentication URI  e.g. mongodb://username:server@mongoserver:10059/somecollection

The code below presupposes you have another file in the same directory called `config.js`. Your config should never be public as it contains your credentials. So for this repository I have added `config.js` to my `.gitignore` but added in a "sample config":https://github.com/thomasdavis/backbonetutorials/blob/gh-pages/examples/nodejs-mongodb-mongoose-restify/config-sample.js.

{% highlight javascript %}
var mongoose = require('mongoose/');
var config = require('./config');
db = mongoose.connect(config.creds.mongoose_auth),
Schema = mongoose.Schema;  
{% endhighlight %}

h4. Mongoose Schema

p. Mongoose introduces a concept of "model/schema":http://mongoosejs.com/docs/model-definition.html enforcing types which allow for easier input validation etc

{% highlight javascript %}
// Create a schema for our data
var MessageSchema = new Schema({
  message: String,
  date: Date
});
// Use the schema to register a model with MongoDb
mongoose.model('Message', MessageSchema); 
var Message = mongoose.model('Message'); 
{% endhighlight %}

Note: `Message` can now be used for all things CRUD related.

h4. Setting up the routes

p. Just like in Backbone, Restify allows you to configure different routes and their associated callbacks. In the code below we want to define two routes.  One for saving new messages and one for retreiving all messages. After we have created our function definitions, we then attach them to either GET/POST/PUT/DELETE on a particular restful endpoint e.g. GET /messages

{% highlight javascript %}
// This function is responsible for returning all entries for the Message model
function getMessages(req, res, next) {
  // Resitify currently has a bug which doesn't allow you to set default headers
  // This headers comply with CORS and allow us to server our response to any origin
  res.header("Access-Control-Allow-Origin", "*"); 
  res.header("Access-Control-Allow-Headers", "X-Requested-With");
  // .find() without any arguments, will return all results
  // the `-1` in .sort() means descending order
  Message.find().sort('date', -1).execFind(function (arr,data) {
    res.send(data);
  });
}



function postMessage(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "X-Requested-With");
  // Create a new message model, fill it up and save it to Mongodb
  var message = new Message(); 
  message.message = req.params.message;
  message.date = new Date() 
  message.save(function () {
    res.send(req.body);
  });
}

// Set up our routes and start the server
server.get('/messages', getMessages);
server.post('/messages', postMessage);

{% endhighlight %}

This wraps up the server side of things, if you follow the "example":https://github.com/thomasdavis/backbonetutorials/blob/gh-pages/examples/nodejs-mongodb-mongoose-restify/server.js then you should see something like

"http://backbonetutorials.nodejitsu.com/messages":http://backbonetutorials.nodejitsu.com/messages


Note: Again you must remember to change the "Model":https://github.com/thomasdavis/backbonetutorials/blob/gh-pages/examples/nodejs-mongodb-mongoose-restify/js/models/message.js and "Collection":https://github.com/thomasdavis/backbonetutorials/blob/gh-pages/examples/nodejs-mongodb-mongoose-restify/js/collections/messages.js definitions to match your server address.

Inside of our function definitions we have used our Mongoose model to perform the appropiate action.

Note: We have created a shortcut to Mongooses Schema variable. Mongoose makes some of the typical MongoDb paradigms easier to implement and understand.

p. You should most always end up with quite a light weight index file.   You can serve this off your server and then the rest of your site off a CDN ensuring that everything that can be cached, will be.

h4. What does the bootstrap look like?

p. Our bootstrap file will be responsible for configuring Require.js and loading initially important dependencies.

In the below example we configure Require.js to create shortcut alias to commonly used scripts such as jQuery, Underscore and Backbone.

Due to the nature of these libraries implementations we actually have to load them in order because they each depend on each other existing in the global namespace(which is bad but is all we have to work with).

Hopefully if the AMD specification takes off these libraries will add code to allow themselves to be loaded asynchronously.   Due to this inconvience the bootstrap is not as intuitive as it could be, I hope to solve this problem in the near future.

We also request a module called "app", this will contain the entireity of our application logic.

**Note:** Modules are loaded relativly to the boot strap and always append with ".js".   So the module "app" will load "app.js" which is in the same directory as the bootstrap.

{% highlight javascript %}
// Filename: main.js

// Require.js allows us to configure shortcut alias
// There usage will become more apparent futher along in the tutorial.
require.config({
  paths: {
    jQuery: 'libs/jquery/jquery',
    Underscore: 'libs/underscore/underscore',
    Backbone: 'libs/backbone/backbone'
  }

});

require([

  // Load our app module and pass it to our definition function
  'app',

  // Some plugins have to be loaded in order due to there non AMD compliance
  // Because these scripts are not "modules" they do not pass any values to the definition function below
  'order!libs/jquery/jquery-min',
  'order!libs/underscore/underscore-min',
  'order!libs/backbone/backbone-min'
], function(App){
  // The "app" dependency is passed in as "App"
  // Again, the other dependencies passed in are not "AMD" therefore don't pass a parameter to this function
  App.initialize();
});

{% endhighlight %}

h3. How should we lay out external scripts?

p. Any modules we develop for our application using AMD/Require.js will be asynchronously loaded.

We have a heavy dependency on jQuery, Underscore and Backbone, unfortunatly this libraries are loaded synchronously and also depend on each other existing in the global namespace.

Below I propose a solution(until these libraries allow themselves to be loaded asynchronously) to allow these libraries to be loaded properly(synchronously) and also removing themselves from global scope.


{% highlight javascript %}
// Filename: libs/jquery/jquery.js

define([
// Load the original jQuery source file
  'order!libs/jquery/jquery-min'
], function(){
  // Tell Require.js that this module returns a reference to jQuery
  return $;
});
{% endhighlight %}

{% highlight javascript %}
// Filename: libs/underscore/underscore
// As above lets load the original underscore source code
define(['order!libs/underscore/underscore-min'], function(){
  // Tell Require.js that this module returns  a reference to Underscore
  return _;
});
{% endhighlight %}

{% highlight javascript %}
 // Filename: libs/backbone/backbone
 // Finally lets load the original backbone source code
define(['order!libs/backbone/backbone-min'], function(){
  // Now that all the orignal source codes have ran and accessed each other
  // We can call noConflict() to remove them from the global name space
  // Require.js will keep a reference to them so we can use them in our modules
  _.noConflict();
  $.noConflict();
  return Backbone.noConflict();
});
{% endhighlight %}

h3. A boiler plate module

p. So before we start developing our application, let's quickly look over boiler plate code that will be reused quite often.

For convience sake I generally keep a "boilerplate.js" in my application root so I can copy it when I need to.

{%highlight javascript %}
//Filename: boilerplate.js

define([
  // These are path alias that we configured in our bootstrap
  'jQuery',     // lib/jquery/jquery
  'Underscore', // lib/underscore/underscore
  'Backbone'    // lib/backbone/backbone
], function($, _, Backbone){
  // Above we have passed in jQuery, Underscore and Backbone
  // They will not be accesible in the global scope
  return {};
  // What we return here will be used by other modules
});
{% endhighlight %}

p. The first argument of the define function is our dependency array, we can pass in any modules we like in the future.

h3. App.js Building our applications main module

p. Our applications main module should always remain quite light weight.   This tutorial covers only setting up a Backbone Router and initializing it in our main module.

The router will then load the correct dependencies depending on the current URL.

{% highlight javascript %}
// Filename: app.js
define([
  'jQuery',
  'Underscore',
  'Backbone',
  'router', // Request router.js
], function($, _, Backbone, Router){
  var initialize = function(){
    // Pass in our Router module and call it's initialize function
    Router.initialize();
  }

  return {
    initialize: initialize
  };
});
{% endhighlight %}

{% highlight javascript %}
// Filename: router.js
define([
  'jQuery',
  'Underscore',
  'Backbone',
  'views/projects/list',
  'views/users/list'
], function($, _, Backbone, Session, projectListView, userListView){
  var AppRouter = Backbone.Router.extend({
    routes: {
      // Define some URL routes
      '/projects': 'showProjects',
      '/users': 'showUsers',

      // Default
      '*actions": "defaultAction'
    },
    showProjects: function(){
      // Call render on the module we loaded in via the dependency array
      // 'views/projects/list'
      projectListView.render();
    },
      // As above, call render on our loaded module
      // 'views/users/list'
    showUsers: function(){
      userListView.render();
    },
    defaultAction: function(actions){
      // We have no matching route, lets just log what the URL was
      console.log('No route:', actions);
    }
  });

  var initialize = function(){
    var app_router = new AppRouter;
    Backbone.history.start();
  };
  return {
    initialize: initialize
  };
});
{% endhighlight %}

h3. Modularizing a Backbone View

Backbone views most usually always interact with the DOM, using our new modular system we can load in Javascript templates using Require.js text! plugin.

{% highlight javascript %}
// Filename: views/project/list
define([
  'jQuery',
  'Underscore',
  'Backbone',
  // Using the Require.js text! plugin, we are loaded raw text
  // which will be used as our views primary template
  'text!templates/project/list.html'
], function($, _, Backbone, projectListTemplate){
  var projectListView = Backbone.View.extend({
    el: $('#container'),
    render: function(){
      // Using Underscore we can compile our template with data
      var data = {};
      var compiledTemplate = _.template( projectListTemplate, data );
      // Append our compiled template to this Views "el"
      this.el.append( compiledTemplate );
    }
  });
  // Our module now returns an instantiated view
  // Sometimes you might return an un-instantiated view e.g. return projectListView
  return new projectListView;
});
{% endhighlight %}

p. Javascript templating allows us to seperate the design from the application logic placing all our html in the templates folder.

h3. Modularizing a Collection, Model and View

p. Now we put it altogether by chaining up a Model, Collection and View which is a typical scenairo when building a Backbone.js application.

First off we will define our model

{% highlight javascript %}
// Filename: models/project
define([
  'Underscore',
  'Backbone'
], function(_, Backbone){
  var projectModel = Backbone.Model.extend({
    defaults: {
      name: "Harry Potter"
    }
  });
  // You usually don't return a model instantiated
  return projectModel;
});
{% endhighlight %}

p. Now we have a model, our collection module can depend on it.  We will set the "model" attribute of our collection to the loaded module.  Backbone.js offers great benefits when doing this.

"Collection.model: Override this property to specify the model class that the collection contains. If defined, you can pass raw attributes objects (and arrays) to add, create, and reset, and the attributes will be converted into a model of the proper type."

{% highlight javascript %}
// Filename: collections/projects
define([
  'Underscore',
  'Backbone',
  // Pull in the Model module from above
  'models/project'
], function(_, Backbone, projectModel){
  var projectCollection = Backbone.Collection.extend({
    model: projectModel
  });
  // You don't usually return a collection instantiated
  return new projectCollection;
});
{% endhighlight %}

Now we can simply depend on our collection in our view and pass it to our Javascript template.

{% highlight javascript %}
// Filename: views/projects/list
define([
  'jQuery',
  'Underscore',
  'Backbone',
  // Pull in the Collection module from above
  'collections/projects',
  'text!templates/projects/list
], function(_, Backbone, projectsCollection, projectsListTemplate){
  var projectListView = Backbone.View.extend({
    el: $("#container"),
    initialize: function(){
      this.collection = new projectsCollection;
      this.collection.add({ name: "Ginger Kid"});
      // Compile the template using Underscores micro-templating
      var compiledTemplate = _.template( projectsListTemplate, { projects: this.collection.models } );
      this.el.html(compiledTemplate);
    }
  });
  // Returning instantiated views can be quite useful for having "state"
  return new projectListView;
});
{% endhighlight %}

h3. Conclusion

p. Looking forward to feedback so I can turn this post and example into quality references on building modular Javascript applications.

Get in touch with me on twitter, comments or github!

h3. Relevant Links

"Organizing Your Backbone.js Application With Modules":http://weblog.bocoup.com/organizing-your-backbone-js-application-with-modules



h3. Author

* "Thomas Davis":https://github.com/thomasdavis

h3. Contributors

* "Jakub Kozisek":https://github.com/dzejkej (created modular-backbone-updated containing updated libs with AMD support)
